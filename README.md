# 2021年中国计算机设计大赛国三项目



## 第 1 章 作品概述
随着时代的进步和发展，海量数据随之产⽣，⼈们也开始对⼤数据越来越重
视起来，⼤数据随之也被⼴泛应⽤起来，像电⼦地图，淘宝抖⾳推荐，都是在⼤
数据现代社会需求中所实现的，⽽最近更是被应⽤到⼈⼯智能⽅⾯来了。我们本
次的作品就是充分地体现⼤数据的特别以及实⽤之处，本作品我们主要完成了对
数据的处理与应⽤，使⽤了有关⼤数据的算法并加以创新，作品名称为对答如流，
主要是通过爬⾍获取数据，处理后⽤ Sunday 算法，加上模糊匹配，对数据进⾏
统计应答。对于计算机相关的技术，我运⽤了：基于 python ⽹络编程技术，基
于 python 的 Functools 缓存技术，⽹络爬⾍技术，数据处理技术，GUI 技术，⽂
件 I/O 操作技术，基于 python 的实现多线程交互，以及核⼼的匹配算法。
本作品的名称为：《对答如流》，我们设⽴了三种不同的数据处理模式：“闲聊
模式”，“古诗模式”，“英⽂模式”，不同模式之间都有⼀种共同特点，主要体现在交
流应答⽅⾯，当输⼊相应的上半句⾃然会对其进⾏数据处理与整合，然后会显示
对应的答句，再使⽤了 GUI 技术，将所实现的项⽬在 GUI 界⾯展示出来，对于
每⼀种模式下的数据处理都有相应指令使其跳出，⾸先打开客户端显示主题⾃⼰
选择模式，接着通过客户端输⼊ 1，2，3 分别进⼊闲聊模式，古诗模式，英⽂模
式(“默认是闲聊模式”)可实现对答交流；
我们在实现字符串匹配功能的时候，第⼀时间想到了在本科阶段学到的
KMP、BF 算法，但是在经过⼤量的测试中，KMP 算法以及 BM 算法在理论上是
很不错的，但是在实际匹配中，它的效率并不是很友好，所以我们决定采⽤ Sunday
算法。Sunday 算法原理将在技术⽅案中体现。
## 第 2 章 问题描述
《对答如流》是在⼤数据盛⾏的环境下所产⽣的⼀个项⽬实践，近代越来越
多的只能⼈⼯智能投⼊使⽤，它们的储存的知识远⽐我们想象的多很多，需要实
现⼈机交互的话就需要在机器中存储海量数据⽅便投⼊使⽤，应实际需求，我们
做了⼀个《对答如流》项⽬作品来解决该问题。该项⽬主要是实现了⼈机之间的
三种语⾔交互，机器中存储了⼤量数据，客户端在输⼊问题后服务端都能及时做
出答复，性能⽅⾯在应⽤ Sunday 算法，以及模糊查询，并且在每个算法中有引
⼊了缓存，这样就简省重复请求的处理的处理速度，可以做出快速响应，以及即
使客户端不⼩⼼字打错了或者打少了，都可以进⾏模糊判断，服务端随之给出相
应客户端所需求的答案。
## 第 3 章 技术⽅案
### 3.1 使⽤ python 爬⾍爬取相关数据集
   - Step1: 需要通过 python 的 request ⽅法发送请求，得到⽬标服务器的响应，得到的⽹⻚的源码。
   - Step2: 在利⽤ xpath 解析技术，通过源码解析出标签中的有⽤的数据，以及
⽬标⽂件的 url 地址。
  -  Step3: 将 url 地址都存在数组中。
  -  Step4: 将数组的 url 地址去除，适当的进⾏ url 的处理，可以通过字符串的
拼接。来使得到的不合法的 url 进⾏改变。
 - Step5: 分别对 url 接着⽤ request ⽅法发送请求。对⾃⼰的爬⾍要进⾏适当
的伪装。
 - Step6: 重复 2 操作，解析出古诗的数据。
 - Step7: 调⽤ python 的 write 函数写⼊⽂件。
### 3.2 数据预处理和⽂件操作：
- Step1: 通过 readlines 读取⽂件。
- Step2: 再通过 split 对所得到的数据进⾏加⼯。
- Step3: 再通过 find 函数进⾏去重再对字符串进⾏拼接写⼊⽂件。
例⼦：主⽂件
降福既多 *** 周公皇祖
- Step4: 再针对初步处理的⽂件进⾏分离，将 3 中的数据进⾏分离。
⽂件 1：降福既多
⽂件 2：周公皇祖
数据处理到此完毕。
## 3.3 匹配算法
### （1）Sunday 算法
    
   通过 KMP 算法进⾏⼦串（输⼊的数据）与⺟串（读取⽂件 1 的数据）进⾏
匹配。但是再执⾏的效果来看，KMP 算法的时间复杂度是⽐较⾼的，就引⼊相
对⽐较快的 Sunday 算法。Sunday 算法的思路 BM 算法差不多。

- BM 的算法原理：
  
  在字符串匹配过程中，模式串发现不匹配时，算法能跳过尽可能多的字符以
进⾏下⼀步的匹配，从⽽提⾼了匹配效率。
- Sunday 算法：
    
    在 Sunday 算法的⽐较过程中核⼼的点在于如果当前匹配失败则是根据被搜
索字符串与搜索字符串的对应部分的后⾯⼀个字符串作为跳转的依据，如果该字
符串不在被搜索字符串中，则直接略过；
如果该字符串在搜索字符串中存在，则将该位置与被搜索字符串中的该字符
串进⾏对⻬，然后从头开始⽐较。
基于 Sunday 算法的字符串匹配，相对于其它字符串匹配算法移除了很多⽆
关的⽐较操作，在短⽂本中的匹配或许不够明显，但是对于越⻓的⽂本则效果越
明显。
### （2）模糊匹配算法
只有输⼊的⼦串是完全属于⺟串才能匹配成功，⽽我们进⾏对话时，⼜如何
保证匹配成功，得到正确的回答呢？针对这个的问题：引出我们的第⼆个核⼼算
法：模糊匹配。模糊匹配的算法思路：
- Step1: 对于输⼊⼦串将他以 K — V 的形式保存。
- Step2: 正好符合 Python 编程语⾔中的字典的形式。
- Step3: K：保存字符；V：保存该字符的数量。
- Step4: ⺟串也是遵守以上处理。
- Step5: 通过遍历⼦串的字典，与⺟串的字典⽐较。
- Step6: 遍历得出，字串中的 key ：value 与⺟串的 key ：value 有多⼤差别。
- Step7: 匹配的结果有三种情况：
> 1）⼦串的 K – V 两个值都符合，那么就给⼦串中的 K 定为 1 分；


> 2）⼦串 K 符合 V 不符合，那么就针对⼦串中的 K 的 V 值（出现的次
数）乘以偏移量的分，偏移量定为 0.15；

> 3）⼦串 K 不符合 V 不符合，定为 0 分。
- Step8: 在这时每个⼦串的字符都有⼀个得分，那么就取出每个字符的分数，
求和。得出最⼤。最⼤的就是匹配结果。
### （3）两种算法的融合
融合思路如下：
Sunday 算法先匹配，如果匹配到了，直接把总分最⼤化。这⾥设置为 100。
Sunday 算法没有匹配成功，则进⼊模糊匹配。
核⼼匹配算法代码如下图：
在之前，读取的⽂件 1 中，因为调⽤ readlines ⽅法返回 list，⼜因为数组中
每⼀⾏数据都有⼀个分数，取出分数最⾼的⼀⾏即可，再返回⽂件 2 中的对应数
据。
算法的优点：匹配的准确度⾮常的⾼
算法的缺点：当读到的数据⽐较多时（每个模式数据量⾼达 20 万⾏），匹配
的速度⽐较慢。
解决匹配英语对话的问题：匹配英⽂数据的话原理给以上差不多，就只是将
匹配字符，换成匹配单词即可。

## 3.4 GUI 编程
  
  本例引⽤ PySimpleGUI 包完成 GUI 编程。
初始化窗⼝函数：
窗体的使⽤：
GUI 界⾯：
参考⽂档：PySimpleGUI 官⽅⽂档: https://pysimplegui.readthedocs.io/en/latest/
## 3.5 多线程 socket 编程-- --多客户端接⼊
Socketserver 简述：socketserver 模块是基于 socket ⽽来的模块，它是在 socket
的基础上进⾏了⼀层封装，并且实现并发等功能。
Socketserver 的简单理解：Socketserver 内部使⽤ IO 多路复⽤以及 “多线程”
和 “多进程” ，从⽽实现并发处理多个客户端请求的 Socket 服务端。即：每个客
户端请求连接到服务器时，Socket 服务端都会在服务器是创建⼀个“线程”或者
“进程” 专⻔负责处理当前客户端的所有请求
注意事项：我们在使⽤的这个模块的时候，我们只需要关注 handle ⽅法的处
理逻辑，在创建多线程的逻辑，有底层⾃⼰会帮我们创建线程，以及回收线程。
原理图如下：第 7 ⻚
基于 socketserver 的程序：
#服务端
import socketserver
class MyTCPHandler(socketserver.BaseRequestHandler):
"""
我们的服务器的请求处理程序类。
这是每个连接到服务器实例化⼀次,
⽽且必须重写 handle ()⽅法来实现通信客户端 """

具体的模块使⽤⽅法来⾃：https://cloud.tencent.com/developer/section/1368518
## 3.6 引⼊缓存技术
缓存是⼀种将定量数据加以保存以备迎合后续获取需求的处理⽅式，旨在加
快数据获取的速度。数据的⽣成过程可能需要经过计算，规整，远程获取等操作，
如果是同⼀份数据需要多次使⽤，每次都重新⽣成会⼤⼤浪费时间。所以，如果
将计算或者远程请求等操作获得的数据缓存下来，会加快后续的数据获取需求。
缓存的原理：通过⽤键值对的⽅式将数据放到字典中，如果下次需要取值时可以
直接到字典中获取。引⼊ lru_cache 最近最少使⽤缓存修饰器。在 Python 的 3.2
版本中，引⼊了⼀个⾮常好的缓存机制，即 functool 模块中的 lru_cache 装饰
器，可以直接将函数或类⽅法的结果缓存到内存中，后续调⽤则直接返回缓存的
结果。 LRU (Least Recently Used，最近最少使⽤) 算法是⼀种缓存淘汰策略。其
根据数据的历史访问记录来进⾏淘汰，核⼼思想是，“如果数据最近被访问过，那
么将来被访问的⼏率也更⾼”。该算法最初为操作系统中⼀种内存管理的⻚⾯置
换算法，主要⽤于找出内存中较久时间没有使⽤的内存块，将其移出内存从⽽为
新数据提供空间。
在进⾏算法匹配中，都是从⽂件⾸⾏开始读取，进⾏匹配，如果每⼀次的请
求，都要重新匹配的的话，这给响应速度⼤⼤折扣。进⼊模糊匹配也是如此，引
⼊缓存，减少了之前已经计算过的过程，直接放回结果。服务端也可能会处理相
同的请求，通过缓存，直接返回结果。⼤⼤提⾼了，节省了服务端的计算资源。

## 第 4 章 系统实现
### 4.1 为解决数据获取问题
通过爬⾍爬取数据信息，得到数据。分别爬取中⽂对答数据，古诗数据，以
及常⽤的中⽂交流数据。得到的数据，进⾏筛选。
### 4.2 为解决数据的格式不符合最终的格式
通过⽂件的 I/O 操作，通过使⽤字符流，或者字节流，来进⾏数据治理。治
理之后的数据，通过 spilt ⽅法实现⽂件的分割
### 4.3 为解决字符串精准匹配的问题
第⼀开始，引⼊本科阶段的 KMP 算法，BM 算法匹配，在实际当中，这个匹
配算法，在数据集⽐较⼤的时候，表现并不怎么好。在这⾥，引⼊了 Sunday 算
法。Sunday 的算法：如果当前匹配失败则是根据被搜索字符串与搜索字符串的
对应部分的后⾯⼀个字符串作为跳转的依据，如果该字符串不在被搜索字符串中，
则直接略过。这样就可以实现快速的匹配，降低了冗余度。
### 4.4 为解决字符串的模糊匹配的问题
⾃⼰开发出⼀种模糊匹配算法。简单⼀点来说就是，给匹配的⼦串和被匹配
的⺟串，按照字符分割，分割的得到字串，在⼀⼀于⺟串中匹配。在给每个字符
打分，再求出字符的总分。总分最⾼者，就是最佳匹配结果。
### 4.5 为解决匹配速度⽐较慢的问题
引⼊ Python 缓存机制与 functools.lru_cache，lru_cache 可以缓存每个函数的
执⾏结果。如何查询缓存的结果才是最重要的。
引出 LinkedHashMap 数据结构
LinkedHashMap 是⼀个复合数据结构，它将 Hash 与双向链表融合在⼀起，
这两种数据结构并不是相互独⽴的，是交叉在⼀起的。通过 Node 关联起来。每
个 Node 都放在 Hash 中，⽽ Node 之间⼜通过双向链表关联。这样保证查询的速
度。
⽽ Python 已经在标准库中实现了 LinkedHashMap，它就是 OrderedDict。第 10 ⻚
### 4.6 为解决界⾯不友好的问题
引⼊了 PySimpleGUI，设置⼀个简单的 GUI，给⼈机交互带来良好的体验。
### 4.7 为解决客户端只有⼀个，极⼤浪费服务端的资源
引⼊多线程 socket 编程，通过 python 的 Socketserver，给我们以后进程或者
线程的创建，回收。这样给开发者带来极⼤的便利。
⽽我们就可以再处理的业务逻辑中⼤放光彩，⽽不是再进程创建回收的问题
带来不必要的麻烦。
### 4.8 ⼀个项⽬没有⼀个 logo 是没有灵魂的
引⼊ pyfiglet
f = Figlet(font='starwars')
print("欢迎进⼊ Answer Glibly")
print(f.renderText(("answer")))
简单的三⾏代码，就实现了类似于 spring 启动的效果。第 11 ⻚
## 第 5 章 系统评测
古诗数据：
来⾃中国古诗⽂⽹：https://www.gushiwen.org/ 。
规模：9628 条数据。
英⽂对答数据：
github ：
https://raw.githubusercontent.com/candlewill/Dialog_Corpus/master/ChatterBot
_corpus/data/english/
规模：10000 ⾏
中⽂对答数据：
GitHub：https://github.com/codemayq/chinese_chatbot_corpus
数据规模：1067852 ⾏第 12 ⻚

Write your name on line 6, save it, and then head back to GitHub Desktop.
## 第 6 章 安装使⽤以及环境配置
### 6.1 环境配置：
开发环境：社区版 pycharm：
https://www.jetbrains.com/pycharm/download/#section=windows
开发系统：windows10
开发语⾔：python
Python 环境：anaconda3 版本 3.6
数据库：⽆
### 6.2安装步骤
- Step1: 下载压缩包
- Step2: 将⽂件解压到任意磁盘个根⽬录下。（注意：是根⽬录）
在这⾥我把⽂件解压到 E：的根⽬录下。
- Step3: 将项⽬导⼊ pycharm第 14 ⻚
- Step4: 下载 anaconda3 后选择 anaconda3 运⾏环境，或者其他 3.6 以上的环
境。
如果在 src 下的源代码出现报错的信息，导⼊对应的包即可解决。具体⽅法：
- Step1: 将⿏标置于红线下⾯，点击安装 package，等待完成。
- Step2: 右下⽅的进度条完成即可。
- Step3: 其他报错解决⽅法同理。
### 6.2 单客户端运⾏：
- Step1：打开 src 下的 service.py ，运⾏。
- Step2: 运⾏ client.py。
- Step3: ⼀定要按照该步骤进⾏，否者出现，该主机拒绝访问的异常，或者其
他的关于⽹络的异常。
- Step4: 运⾏起来后，在命令⾏中会出现,对答如流的英⽂字样，以及模式的
类型。
- Step5: 在主⻚⾯会出现⼀个聊天窗⼝.
- Step6: 到此程序正常运⾏。

### 6.3 多客户端的运⾏
- Step1：先启动 service.py 再命令⾏中显示 wait connect
当出现异常情况：第 16 ⻚
这个就代表，再没有终结之前的服务端，或者多次启动服务端造成的结果。
- Step2：启动 client.py，再命令⾏中可以看到 logo 以及选择模式，在下⽅会
出现⼀个程序运⾏的窗体。第 17 ⻚
- Step3：但是再 Pycharm 中右键直接点击 Run 的时候
会出现：
这时就代表只能启动⼀个客户端。
- Step4：但是我们可以第 18 ⻚
- Step5：选择 Run File in python Console 选项运⾏。
在服务端中会出现
这样就完成了多客户的连接。
- Step6：退出可以使⽤任何⼿段取中段 client，在 service 端会出现第 
- Step7：到次程序正常退出。
### 6.4 程序使⽤步骤：
- Step1: 第⼀次输⼊是选择模式。
如果第⼀次输⼊没有选择模式，则按照模式 1 运⾏
输⼊数字 1，进⼊闲聊模式。
输⼊数字 2，进⼊古诗模式。
输⼊数字 3，进⼊英⽂模式。
点击“发送”即可，模式之间可以随意切换。
